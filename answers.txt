1. Чем отличается класс от объекта? Приведите примеры и того, и другого, отличные от указанных в уроке.

    Класс — это набор свойств и методом для создания объектов, т.н. шаблон или структура.

        class Worker {
            constructor(name, position, salary) {
            this.name: name,
            this.position: position,
            this.salary: salary,
            }

            reward(sum) {
            this.salary = this 
            .salary + sum;
            }
        }

    let sasha = new Worker(Sasha, receuiter, 50000);
    Sasha.reward(10000);
                                    
    Объект — это набор переменных со значениями, это могут быть как обычные значения, так и функции. 

        let primorskayaGasStation {
        name: "Приморская",
        manager: "Татьяна",
        director: "Ирина",
        salers: 8,
        vacancies: 2,
        changeSalers(employed, dismissed) {
        this.salers = this.salers + employed - dismissed;
        this.vacansies = this.vacancies + emloyed - dismissed;
            }
        }

2. Приведите примеры объектно-ориентированного подхода в реальной жизни. 

    Примеры ООП в жизни: 
        1) Организация выходных (город, место, компания, занятие, ресторан);
        2) Паста (тесто, паста, соус, добавки, сыр)
        3) Комплект одежды (верх, низ, обувь, верхняя одежда, аксессуары)

    Приведите примеры объектно-ориентированного подхода в программировании. 

        1) Данные пользователя (Имя, Возраст, Пол, Логин, Пароль)
        2) Предпочтения пользователя к ресурсу (Цветовая схема, Выбранные интересные темы в ленте, размер шрифта, если есть какие-то блоки, которые можно перемещать - их расположение)
        3) Бронирование стола в ресторане/гостиницы (Имя забронировавшего, Количество людей, Дата создания брони, Дата самой брони, Пожелания, Какой номер/стол закреплён за бронью и т.д.)

3. Что такое конструктор? Самостоятельно изучите и напишите, какие бывают виды конструкторов.

    Конструктор - метод, который запускается во время создания объекта с помощью class. Должен быть выполнен до того, как вызваны остальные методы и может быть только один в классе. Новые свойства в существующий конструктор добавить извне нельзя, только изменив сам метод в классе.

    Есть встроенные конструкторы у собственных  объектом и те конструкторы, которые мы пишем сами.
    
    Есть конструктор не определён - используется конструктор по-умолчанию, либо пустой. Если класс производный (class ChildClass extends ParentClass {}), то по умолчанию вызывается родительский конструктор и передаёт любые агрументы, которые были предоставлены. Это в том случае, если нам не нужен собственный конструктор, т.е. мы не будет инициализировать класс. 

    Но если нам нужен собственный конструктор в производном классе, то родительский конструктор нужно объявить (constructor(el) {super(el); и далее свои параметры конструктора})

4.  function bike() {
        console.log(this.name);
    }

    let name = "ninja";
    let obj1 = {
        name: "pomidor",
        bike: bike,
    }

    let obj2 = {
        name: "site",
        bike: bike,
    }

    bike(); // выводит ninja
    obj1.bike(); // pomidor
    obj2.bike(); // site

    Значение this в функциях зависит от окружения. В первом случае функция обращается к поиску "name" сначала внутри функции (то есть сама функция и есть this), затем вне функции (окружение вне функции становится this), и находит переменную "name".
    Во втором и третьем случае метод bike с переданной ему функцией bike обращается к первому окружению, которое находит: к объекту и возвращает name из объекта.

    НО! Это работает только в не строгом режиме JS, т.к. это небезопасно. При "use strict" выдаёт ошибку. this дальше функции поиск name делать не будет. 

5.  Чем статические свойства и методы отличаются от нестатических? В каких ситуациях они применяются?

    Статические свойства и методы не привязанны к конкретному объекту и существуют без его создания. 

    Обозначаются в классе ключевым словом static. 
    
    Методы. Если обычные методы объявляются как свойства объекта prototype и храняться внутри каждого объекта класса, то static не занимает память каждого объекта, хранится в классе, а при вызове создаёт нужный метод по указаному синтаксису. Наследуются производственным классам.

    Свойства. Принадлежат самому классу, в объекты не копируются. Можно, например, считать количество созданных объектов класса, добавив в конструтор ClassName.staticProperty++.

6.  Самостоятельно изучите, что такое геттеры и сеттеры, приведите пример класса с их использованием.

    Геттеры и сеттеры помогают распределить доступностьданных в классе. С помощью геттеров мы можем прочитать информацию в классе (никаких параметров, для одного свойства - один геттер, имя геттера и свойства не должны совпадать), а с помощью сеттеров установить информацию в нужное место, т.е. изменить (ровно один параметр, имя сеттера и свойства не должны совпадать). 

7.  class Person {
        constructor(name) {
            this.name = name
        }
    }

    const member = new Person("John");
    console.log(typeof member); // object, создан из класса Person, с помощью конструктора объекту member присвоено свойство name со значением, переданным при инициализации.


8.  const person = {
        name: "Valera",
        age: 23,
    }


    let city = person.city; // объявление переменной со значением несуществующего свойства city объекта person
    // чтобы добавить объекту person свойство city, нужно писать так:
    // person.city = "Saint-Petersburg"
    city = "Amsterdam"; // значение переменной city просто перезаписалось

    console.log(person); // вывод: объект person со свойствами name и age



