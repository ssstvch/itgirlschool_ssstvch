1. В компонент передаются атрибуты `description` и `title` . Могу ли я их сложить как на примере, чтобы получить одну строку и вывести в компоненте?
    

    import React from "react";
    import styles from './button.css'
    
    export default class Example extends React.Component {
        render() {
    				let {id,title} = this.props
    				title += description;
             return (
                <span>{title}</span>
            );
        }
    }

    Как на примере не получится, так как пропс description не объявлен. Если будет объявлен - сработает без пробела между title и description. Если нужен пробел, можно записать так: title =+ ` ${description}`
    
2. С помощью какого метода можно отловить изменение `props`?

    shouldComponentUpdate()

3. Оператор расширения часто используется также для клонирования объекта. Подумайте, чем отличаются эти две записи и какую проблему решает здесь оператор расширения:
    
    const initialObj = { title:'Hello', text:'World' }
    
    //№1
    const firstObj = initialObj
    
    //№2
    const secondObj = {...initialObj}
    
    Первый вариант это присваивание константе ссылки на объект. 
    А второй вариант это неглубокое копирование (если бы была вложенность, она бы не копировалась)
    
4. В каком из методов жизненного цикла лучше всего использовать методы вызова API и обращения к веб-хранилищам, если они должны быть вызваны всего один раз при загрузке страницы?

    componentDidMount()

5. С помощью какого метода можно отловить и отрисовать для пользователя возникшую в компоненте ошибку?

    componentDidCatch()

6. Какой код обычно пишут в конструкторе? Для каких задач он используется?

    Инициализируют компонент. Прописывают пропсы (обязательно определять пропсы через super(props)) и изначальный стейт. Также в конструкторе вешают обработчики событий для компонента. 

7. Что делает функция `render`()? Что может ее вызвать?

    render() рисует и перерисовывает компонент в DOM. Вызывается всегда при создании и монтировании компонента в DOM (отрисовывает компонент, дальше уже перерисовывает существующий). 

    Перерисовывается (вызывается функция render()):
        - когда меняется родительский компонент, если изменения затрагивают ребёнка;
        - когда меняется стейт (this.setState());
        - при вызове this.forceUpdate() - запускает все методы жизненного цикла, кроме shouldComponentUpdate() для себя и всех дочерних компонентов (не стоит испольовать);
        - при перехвате ошибки (this.componentDidCatch()).

8. Что нужно изменить в коде из урока (видео), чтобы начальные параметры у компонента приходили из пропсов, но если пропсы вообще не заданы, начальные значения были инициализированы нулями?

    let {minutes, seconds} = props && 0;

9. Можно ли несколько раз использовать хук `useEffect` внутри одного компонента?

    да, можно

10. Можно ли не передавать второй аргумент в хук `useEffect`, что  тогда произойдет?

    без второго аргумента useEffect будет вызываться при любом изменении компонента (после каждого рендера).

11. Что означает возвращение функции в теле эффекта? 

    При возвращении функции в теле эффекта React читает useEffect как componentWillUnMount, то есть размонтирует компонент.

12. Будут ли перерисованы дочерние элементы компонента при вызове метода `forceUpdate`()?

    Да, будут перерисованы, но состояние затронуто не будет, так как функция не отслеживает состояние компонентов. 