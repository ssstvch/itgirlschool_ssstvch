1. Приведите примеры GET-вызовов с параметрами (2-3 возможных адреса URL, можно реальных, можно из головы)?

    https://spb.hh.ru/employer/vacancyresponses?vacancyId=46104110&hhtmFrom=employer_vacancies - отклики на вакансию по id
    
    https://yandex.ru/maps/2/saint-petersburg/ - карта спб

    https://spb.vkusvill.ru/bonuses/sezonnye-aktsii/ - сезонные акции вкусвилла
    *Например,* 

    
2. Расскажите своими словами, чем отличаются GET и POST-запросы?

    Способом передачи данных. GET - через URL (имя=значение), а POST в теле запроса (скрыт от пользователя)

3. Какой вид запроса лучше использовать для получения отфильтрованного списка товаров? 

    GET

4. А какой - для формы регистрации? 

    SET

5. Посмотрите на запрос и разберитесь, что он делает и что означают и на что влияют параметры api_key, q, limit, lang? Как сделать так, чтобы запрос возвращал не 25, а 5 картинок? 
    
    api_key - персональный ключ для доступа к api giphy,
    q - запрос, по которому передаются объекты,
    limit - максимальное количество переданных объектов,
    lang - язык по умолчанию для местного контента.

    чтобы запрос возвращал 5 картинок, нужно изменить значение limit.
    
    https://api.giphy.com/v1/gifs/search?api_key=lQJ9BIU9QoeorJeS5Z9xEiyfLAmlGh5E&q=cats&limit=5&offset=0&rating=g&lang=en
    
6. Как посмотреть заголовки запроса к странице или API?

    в mozilla - ctrl + I 
    в chrome - f12 > network, если отсутствуют, нужно перезагрузить страницу


7. Самостоятельно разберитесь, что такое CORS. Приведите пример их включения в запросе `fetch`.

    Дословно - "совместное использование ресурсов между разными источниками". 
    Историческое начало в 1993 - был создан тег img, который обращался на стрононний источник. Запрос между источниками и есть начало CORS - обращение к субресурсу. Сейчас CORS даёт контролировать доступ к тегам на сайте по сети. 

    Существует правило безопасности SOP (правило одинокого источника), когда по умолчанию мы можем получить доступ к ресурсам только в том случае, если источник ресурса и источник запроса совпадают (если я правильно поняла, доменное имя должно быть идентичным, протокол (http / https) тоже, отсутствовал субдомен и был идентичный порт), правило распространяется и на стороне клиента, то есть и на JavaScript. 

    Но нам же нужно периодически обращаться к совсем сторонним истоничникам, API и к серверам. Чтобы в таком случае обсепечить безопасность используют механизм CORS. 

    На основе значений определённых заголовков для CORS в HTTP-запросе браузеры (или другие пользовательские агенты) могу проводить запросы к другим источникам, которые без CORS были бы заблокированы. 

    Когда мы делаем запрос к другому источнику, клиент автоматически подставляется доп.заголовок Origin в HTTP-запрос. Значение этого заголовка отражает источник запроса. То есть, чтобы браузер разрешил доступ к ресурсам из другого источника, он должен получить определённые заголовки в ответе от сервера, которые будут указывать на то разрешает ли сервер такие запросы. 

    Начинаются такие заголовки с Access-Control-*. Их несколько, но нужен в итоге только один - Access-Control-Allow-Origin. Это значение должно определять из каких источников мы можем получить доступ к ресурсам. 

    Разрешить доступ из всех источников можно, указав спецсимвол *.

    Другой запрос - Access-Control-Allow-Methods. Он разрешает запросы из других источников, которые выполнены с применением только определённых перечисленных методов. 

    Методы бывают простые и предварительные.
    Предварительные запросы требуют дополнительных проверок и запросов к серверу.

    Запрос мы делаем через fetch. Например: 

    fetch(
        'http://localhost:4000/website',
        {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(string)
        }
    )
    .then(resp => resp.text())
    .then(console.log);

    Если этот запрос ввести на любом другом сайте, отличном от нашего, то нам выдаст ошибку CORS. Плюс запроса будет два (значала предварительный запрос OPTION, потом POST). Предварительный запрос делается, если CORS видит, что наш запрос сложный (использует методы отличные от GET, POST, или HEAD, либо включает заголовки отличные от Accept, Accept-Language или Content-Language, либо имеет значение заголовка Content-Type отличное от application/x-www-form-urlencoded, multipart/form-data, или text/plain.
    ). Чтобы запрос сработал, для начала на сервере нужно разрешить запросы от стороннего источника (одного, нескольких или всех), то есть прописать на стороне сервера:
    
    option "/website" do |env| 
        env.response.headers["Access-Control-Allow-Origin"] = "https://сторонний_источник.ру"
    end
    
    Тем самым запрос OPTION будет выполнен, ответ получен, но! он пока не может быть считан браузером, поэтому мы опять видим ошибку CORS. Прописываем на стороне сервера:

    post "/website" do |env|
        env.response.headers["Access-Control-Allow-Origin"] = "https://сторонний_источник.ру"
    end

    И всё работает.


8. Что можно писать в параметре заголовков `Content-Type` ?

    mime-тип документа. например, text/html, text/plain, application/json, application/pdf и т.д.


9. Давайте отправим информацию о собачке в API по адресу `localhost/pets/add` 

    fetch(
        'http://localhost/pets/add',
        {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                "breed": "Beagle",
                "size": "large",
                "color": "orange",
                "age": 6,
            }),
        },
    )
    
10. Изучите статью [https://learn.javascript.ru/promise-basics] и самостоятельно разберитесь, что такое промисы. Напишите в 1-2 предложения, что это такое и приведите пример, где вы уже сталкивались с промисами?

    Промисы - это объект, который используется для отложенных и асинхронных вычислений и хранит в себе своё состояние (ожидание, решённый или ошибка), результат (если есть) и колбэки. Результат промиса мы можем получить только один раз. 

    Промис у меня появлялся в консоли, когда обрабатывала данные из localStorage. 
